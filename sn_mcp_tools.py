"""
FastMCP server exposing create_business_rule via HTTP/SSE.
Run: python servicenow_br_mcp_server.py
"""

import os, sys, httpx, asyncio 
from typing import Optional, List, Dict, Any
from fastmcp import FastMCP

mcp = FastMCP("sn_br_mcp_server")

# ----- ServiceNow credentials -----
SN_URL  = os.getenv("SERVICENOW_INSTANCE_URL", "").rstrip("/")
SN_USER = os.getenv("SERVICENOW_USERNAME", "")
SN_PASS = os.getenv("SERVICENOW_PASSWORD", "")

@mcp.tool()
async def create_business_rule(
        name: str,
        table: str,
        script: str,
        when: str = "before",
        active: bool = True,
        description: Optional[str] = None
) -> str:
    """Create/replace a Business Rule and return its sys_id."""
    payload = {
        "name": name,
        "collection": table,
        "when": when,
        "active": str(active).lower(),
        "script": script,
        "description": description or f"Generated by FastMCP on {table}"
    }
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.post(f"{SN_URL}/api/now/table/sys_script", json=payload)
        # Log everything for debugging
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)

        try:
            r.raise_for_status()
            return r.json()["result"]["sys_id"]
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def list_business_rules(
        query: str,
        table: Optional[str] = None,
        limit: int = 5
) -> List[Dict[str, Any]]:
    """List top Business Rules based on query and optional table filter, up to the limit."""
    # Construct query params
    params = {
        "sysparm_limit": str(limit),
        "sysparm_display_value": "true",
        "sysparm_exclude_reference_link": "true",
        "sysparm_query": f"nameLIKE{query}"
    }
    
    # Add table filter if specified
    if table:
        params["sysparm_query"] += f"^collection={table}"
    
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.get(f"{SN_URL}/api/now/table/sys_script", params=params)
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            results = r.json()["result"]
            # Return only the relevant fields
            return [{
                "sys_id": rule.get("sys_id", ""),
                "name": rule.get("name", ""),
                "table": rule.get("collection", ""),
                "when": rule.get("when", ""),
                "active": rule.get("active", ""),
                "description": rule.get("description", "")
            } for rule in results]
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def update_business_rule(
        sys_id: str,
        script: str,
        name: Optional[str] = None,
        table: Optional[str] = None,
        when: Optional[str] = None,
        active: Optional[bool] = None,
        description: Optional[str] = None
) -> str:
    """Update an existing Business Rule by sys_id and return its sys_id."""
    # Build payload with only provided fields
    payload = {"script": script}
    if name:
        payload["name"] = name
    if table:
        payload["collection"] = table
    if when:
        payload["when"] = when
    if active is not None:
        payload["active"] = str(active).lower()
    if description:
        payload["description"] = description
    
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.put(f"{SN_URL}/api/now/table/sys_script/{sys_id}", json=payload)
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            return r.json()["result"]["sys_id"]
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def create_client_script(
        name: str,
        table: str,
        script: str,
        type: str = "onLoad",
        active: bool = True,
        description: Optional[str] = None
) -> str:
    """Create/replace a Client Script and return its sys_id."""
    payload = {
        "name": name,
        "table": table,
        "script": script,
        "type": type,
        "active": str(active).lower(),
        "description": description or f"Generated by FastMCP on {table}"
    }
    
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.post(f"{SN_URL}/api/now/table/sys_script_client", json=payload)
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            return r.json()["result"]["sys_id"]
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def list_client_scripts(
        query: str,
        table: Optional[str] = None,
        limit: int = 5
) -> List[Dict[str, Any]]:
    """List top Client Scripts based on query and optional table filter, up to the limit."""
    # Construct query params
    params = {
        "sysparm_limit": str(limit),
        "sysparm_display_value": "true",
        "sysparm_exclude_reference_link": "true",
        "sysparm_query": f"nameLIKE{query}"
    }
    
    # Add table filter if specified
    if table:
        params["sysparm_query"] += f"^table={table}"
    
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.get(f"{SN_URL}/api/now/table/sys_script_client", params=params)
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            results = r.json()["result"]
            # Return only the relevant fields
            return [{
                "sys_id": script.get("sys_id", ""),
                "name": script.get("name", ""),
                "table": script.get("table", ""),
                "type": script.get("type", ""),
                "active": script.get("active", ""),
                "description": script.get("description", "")
            } for script in results]
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def update_client_script(
        sys_id: str,
        script: str,
        name: Optional[str] = None,
        table: Optional[str] = None,
        type: Optional[str] = None,
        active: Optional[bool] = None,
        description: Optional[str] = None
) -> str:
    """Update an existing Client Script by sys_id and return its sys_id."""
    # Build payload with only provided fields
    payload = {"script": script}
    if name:
        payload["name"] = name
    if table:
        payload["table"] = table
    if type:
        payload["type"] = type
    if active is not None:
        payload["active"] = str(active).lower()
    if description:
        payload["description"] = description
    
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.put(f"{SN_URL}/api/now/table/sys_script_client/{sys_id}", json=payload)
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            return r.json()["result"]["sys_id"]
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def get_business_rule(sys_id: str) -> Dict[str, Any]:
    """Get a specific Business Rule by sys_id."""
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.get(f"{SN_URL}/api/now/table/sys_script/{sys_id}")
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            result = r.json()["result"]
            return {
                "sys_id": result.get("sys_id", ""),
                "name": result.get("name", ""),
                "table": result.get("collection", ""),
                "when": result.get("when", ""),
                "active": result.get("active", ""),
                "description": result.get("description", ""),
                "script": result.get("script", "")
            }
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def get_client_script(sys_id: str) -> Dict[str, Any]:
    """Get a specific Client Script by sys_id."""
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.get(f"{SN_URL}/api/now/table/sys_script_client/{sys_id}")
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            result = r.json()["result"]
            return {
                "sys_id": result.get("sys_id", ""),
                "name": result.get("name", ""),
                "table": result.get("table", ""),
                "type": result.get("type", ""),
                "active": result.get("active", ""),
                "description": result.get("description", ""),
                "script": result.get("script", "")
            }
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

# ---------- launch on HTTP/SSE transport ----------
if __name__ == "__main__":
    # binds 0.0.0.0:9123 → /sse  /call  /openapi.json
    asyncio.run(mcp.run_sse_async(host="0.0.0.0", port=9123, log_level="info"))
